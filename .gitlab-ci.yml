stages:
    - test
    - build
    - deploy
    - pages

test:
    stage: test
    image: docker:20.10.16
    services:
        - name: docker:20.10.16-dind
          alias: docker
    variables:
        DOCKER_HOST: tcp://docker:2375
    before_script:
        - apk add --no-cache docker-compose
    script:
        - echo "Running security scan for known vulnerabilities..."
        - docker build --target deps -t deps-image .
        - docker run --rm deps-image npm audit --audit-level=high

        - echo "Running backend integration tests..."
        - docker-compose -f docker-compose.test.yml up --build --abort-on-container-exit
        - echo "Tests passed!"

build:
    stage: build
    image: docker:20.10.16
    services:
        - name: docker:20.10.16-dind
          alias: docker
    variables:
        DOCKER_HOST: tcp://docker:2375
    needs:
        - test
    before_script:
        - echo $REGISTRY_PASSWORD | docker login -u $REGISTRY_USER --password-stdin $CI_REGISTRY
    script:
        - echo "Building and pushing backend image..."
        - docker build --target runner -t ${CI_REGISTRY_IMAGE}:latest .
        - docker push ${CI_REGISTRY_IMAGE}:latest

        - echo "Building frontend..."
        - apk add --no-cache git
        - git clone "https://gitlab-ci-token:${CI_JOB_TOKEN}@gitlab.com/taskmanager-group/taskmanager_frontend.git" ../frontend
        - docker run --rm -v "$(pwd)/../frontend:/app" -w /app node:22 sh -c "npm ci && npm run build"
        - mv ../frontend/dist ./frontend-dist

        - echo "Building and pushing NGINX image..."
        - docker build -f nginx/Dockerfile -t ${CI_REGISTRY_IMAGE}/nginx:latest .
        - docker push ${CI_REGISTRY_IMAGE}/nginx:latest

deploy:
    stage: deploy
    image: alpine:latest
    needs:
        - build
    before_script:
        - apk add --no-cache openssh-client
        - echo "$SSH_PRIVATE_KEY" | base64 -d > deploy_key.pem
        - chmod 600 deploy_key.pem
        - mkdir -p ~/.ssh && chmod 700 ~/.ssh
        - ssh-keyscan $SSH_SERVER_IP >> ~/.ssh/known_hosts
    script:
        - echo "Deploying services to server..."
        - export SSH_OPTIONS="-i deploy_key.pem -o StrictHostKeyChecking=no"

        - |
            ssh $SSH_OPTIONS ${SSH_USER}@${SSH_SERVER_IP} "
              set -e
              mkdir -p ~/taskmanager-prod && cd ~/taskmanager-prod
              
              echo '==> Writing docker-compose.yml on server...'
              echo '${DOCKER_COMPOSE_PROD_CONTENT}' > docker-compose.yml

              echo '==> Creating .env file on server...'
              echo 'DATABASE_URL=postgresql://myuser:mypassword@db:5432/taskmanager' > .env
              echo 'PORT=3000' >> .env
              echo 'JWT_ACCESS_SECRET=${JWT_ACCESS_SECRET}' >> .env
              echo 'JWT_REFRESH_SECRET=${JWT_REFRESH_SECRET}' >> .env
              echo 'JWT_ACCESS_EXPIRATION=${JWT_ACCESS_EXPIRATION}' >> .env
              echo 'JWT_REFRESH_EXPIRATION=${JWT_REFRESH_EXPIRATION}' >> .env
              echo 'GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}' >> .env
              echo 'GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}' >> .env
              echo 'RECAPTCHA_SECRET_KEY=${RECAPTCHA_SECRET_KEY}' >> .env
              echo 'GOOGLE_CALLBACK_URL=${GOOGLE_CALLBACK_URL}' >> .env
              echo 'FRONTEND_URL=${FRONTEND_URL}' >> .env
              echo 'NODE_ENV=production' >> .env
              
              echo '==> Logging into GitLab Registry...'
              docker login -u ${REGISTRY_USER} -p ${REGISTRY_PASSWORD} ${CI_REGISTRY}
              
              echo '==> Pulling the latest images...'
              docker compose pull
              
              echo '==> Running database migrations...'
              docker compose run --rm app npx prisma migrate deploy
              
              echo '==> Restarting services...'
              docker compose up -d --force-recreate
              
              echo '==> Cleaning up old images...'
              docker system prune -af

              echo '==> Deployment successful!'
            "
    variables:
        DOCKER_COMPOSE_PROD_CONTENT: |
            services:
              app:
                image: ${CI_REGISTRY_IMAGE}:latest
                restart: always
                env_file: [".env"]
                depends_on:
                  db: { condition: service_started }
                healthcheck:
                  test: ["CMD", "curl", "-f", "http://localhost:3000/healthz"]
                  interval: 10s
                  timeout: 5s
                  retries: 5
                  start_period: 30s
              nginx:
                image: ${CI_REGISTRY_IMAGE}/nginx:latest
                restart: always
                ports: ["80:80", "443:443"]
                volumes: ["/etc/letsencrypt:/etc/letsencrypt:ro", "/var/www/html:/var/www/html"]
                depends_on:
                  app: { condition: service_healthy }
              db:
                image: postgres:14.1-alpine
                restart: always
                environment:
                  POSTGRES_USER: myuser
                  POSTGRES_PASSWORD: mypassword
                  POSTGRES_DB: taskmanager
                volumes: ["db_data:/var/lib/postgresql/data"]
              certbot:
                image: certbot/certbot
                volumes: ["/etc/letsencrypt:/etc/letsencrypt", "/var/www/html:/var/www/html"]
            volumes:
              db_data: {}
    rules:
        - if: $CI_COMMIT_BRANCH == 'main'

pages:
    stage: pages
    image: node:22-alpine
    needs: []
    script:
        - echo "Installing Redocly CLI..."
        - npm install -g @redocly/cli
        - echo "Building documentation from swagger.yaml..."
        - redocly build-docs swagger.yaml -o public/index.html
        - echo "--- Listing contents of public directory for debugging ---"
        - ls -laR public
    artifacts:
        paths:
            - public
    rules:
        - if: $CI_COMMIT_BRANCH == 'main'
