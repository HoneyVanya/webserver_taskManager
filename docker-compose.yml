services:
    # Service 1: Our Application ('app')
    app:
        # This tells Docker Compose to build an image using the Dockerfile
        # in the current directory (.) instead of pulling a pre-made image.
        build: .
        ports:
            # We can still map port 3000 to our host machine for direct debugging if needed.
            - '3000:3000'
        env_file:
            - ./docker.env
        # This ensures our app container won't start until the 'db' container is ready.
        depends_on:
            - db

    # Service 2: NGINX Reverse Proxy ('nginx')
    nginx:
        image: nginx:stable-alpine
        ports:
            # This is the main entry point. It maps port 80 on your host machine
            # to port 80 inside the NGINX container.
            - '8080:8080'
        volumes:
            # This mounts our custom nginx.conf file into the container,
            # overwriting the default configuration.
            - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf
        depends_on:
            - app # NGINX won't start until our 'app' container is ready.

    # Service 3: The Database ('db') - mostly unchanged
    db:
        image: postgres:14.1-alpine
        restart: always
        environment:
            - POSTGRES_USER=myuser
            - POSTGRES_PASSWORD=mypassword
            - POSTGRES_DB=taskmanager
        ports:
            - '5432:5432'
        volumes:
            - db_data:/var/lib/postgresql/data

# This defines the persistent volume for our database data.
volumes:
    db_data:
